/*
 * Copyright (C) 2025 Open Source Digital Signage Initiative.
 *
 * You can redistribute it and/or modify
 * it under the terms of the Elastic License 2.0 (ELv2) as published by
 * the Search AI Company, either version 3 of the License, or
 * any later version.
 *
 * You should have received a copy of the GElastic License 2.0 (ELv2).
 * see <https://www.elastic.co/licensing/elastic-license>.
 */
import { createWorkflow, createStep } from '@mastra/core/workflows';
import { z } from 'zod';
import { logger } from '../../logger';
import { summarizeAndAnalyzeTool } from '../../tools/market-research/summarizeAndAnalyze';
import { generateChartTool, createPowerpointTool } from '../../tools/presenter';
import { parseJsonStrings } from '../../tools/xibo-agent/utility/jsonParser';
import { promises as fs } from 'fs';
import path from 'path';
import { config } from '../../tools/xibo-agent/config';

// --- Helper Functions and Schemas ---

const hexColorSchema = z.string().regex(/^#[0-9a-fA-F]{6}$/, "Must be a valid 6-digit hex color code (e.g., #RRGGBB)");

/**
 * Defines the structure for a single slide's design, as determined by the design AI.
 */
const slideDesignSchema = z.object({
  title: z.string().describe("The main title of the slide."),
  layout: z.enum(['title_slide', 'section_header', 'content_with_visual', 'content_only', 'quote'])
    .describe("The layout type for the slide."),
  bullets: z.array(z.string()).describe("A list of key bullet points for the slide."),
  visual_suggestion: z.enum(['bar_chart', 'pie_chart', 'line_chart', 'none']).describe("The suggested type of visual for the slide."),
  context_for_visual: z.string().describe("The specific topic or data context from the report needed to create the visual."),
  special_content: z.string().optional().describe("Special content for layouts like 'quote'."),
});
type SlideDesign = z.infer<typeof slideDesignSchema>;

/**
 * Defines the structure for chart data, to be generated by the analyst AI.
 */
const chartDataSchema = z.object({
    chart_type: z.enum(['bar', 'pie', 'line']),
    title: z.string(),
    labels: z.array(z.string()),
    data: z.array(z.number()),
});
type ChartData = z.infer<typeof chartDataSchema>;

const successOutputSchema = z.object({
    success: z.literal(true),
    data: z.object({
        powerpointPath: z.string(),
    }),
});
const errorOutputSchema = z.object({
    success: z.literal(false),
    message: z.string(),
});
const finalOutputSchema = z.union([successOutputSchema, errorOutputSchema]);


// --- Workflow Definition ---

/**
 * @workflow intelligent-presenter-workflow
 * This workflow automates the creation of a PowerPoint presentation from a given markdown report.
 * It follows a multi-step process involving several AI agents:
 * 1. Read Report: Reads the source markdown file.
 * 2. Design Presentation: An AI designs the slide structure and theme.
 * 3. Generate Title Image: An AI generates a background image for the title slide.
 * 4. Generate Content: AIs generate speech notes and data for charts.
 * 5. Generate Visuals: The system creates chart images from the data.
 * 6. Assemble Outputs: All components are combined into a final .pptx file.
 */
export const intelligentPresenterWorkflow = createWorkflow({
  id: 'intelligent-presenter-workflow',
  description: 'Generates a PowerPoint presentation with speaker notes from a markdown report file.',
  inputSchema: z.object({
    reportFileName: z.string().describe('The name of the report file located in persistent_data/reports.'),
    fileNameBase: z.string().optional().describe('The base name for the output files. Defaults to the report file name.'),
  }),
  outputSchema: finalOutputSchema,
})
.then(createStep({
    /**
     * @step read-report-file
     * Reads the content of the specified report file from the 'reports' directory.
     * If the file cannot be read, it forwards an error message to the next step.
     */
    id: 'read-report-file',
    inputSchema: z.object({
        reportFileName: z.string(),
        fileNameBase: z.string().optional(),
    }),
    outputSchema: z.object({
        reportContent: z.string(),
        fileNameBase: z.string(),
        errorMessage: z.string().optional(),
    }),
    execute: async (params) => {
        const { reportFileName, fileNameBase } = params.inputData;
        const resolvedFileNameBase = fileNameBase || path.parse(reportFileName).name;
        const filePath = path.join(config.reportsDir, reportFileName);
        logger.info({ filePath, resolvedFileNameBase }, "ğŸ“„ Reading report file...");
        
        try {
            await fs.access(filePath);
            const reportContent = await fs.readFile(filePath, 'utf-8');
            return { reportContent, fileNameBase: resolvedFileNameBase };
        } catch (error) {
            const message = `Report file not found or could not be read: ${filePath}`;
            logger.error({ filePath, error }, message);
            return { reportContent: '', fileNameBase: resolvedFileNameBase, errorMessage: message };
        }
    },
}))
.then(createStep({
    /**
     * @step design-presentation
     * Uses an AI to analyze the report content and design the presentation structure.
     * It defines the layout, title, and visual suggestions for each slide, plus a theme.
     * It includes robust parsing to handle various formats of AI-generated JSON.
     */
    id: 'design-presentation',
    inputSchema: z.object({
        reportContent: z.string(),
        fileNameBase: z.string(),
        errorMessage: z.string().optional(),
    }),
    outputSchema: z.object({
        presentationDesign: z.array(slideDesignSchema),
        reportContent: z.string(),
        fileNameBase: z.string(),
        themeColor1: z.string().describe("The primary theme color for the presentation background gradient."),
        themeColor2: z.string().describe("The secondary theme color for the presentation background gradient."),
        errorMessage: z.string().optional(),
    }),
    execute: async (params) => {
        const { reportContent, fileNameBase, errorMessage } = params.inputData;
        if (errorMessage) {
            return { presentationDesign: [], reportContent, fileNameBase, errorMessage, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
        }
        
        logger.info("ğŸ¤– [Designer AI] Analyzing report and designing presentation structure...");
        let designResult;
        try {
            // Prompt for the Designer AI to create the presentation structure and theme.
            const prompt = `ã‚ãªãŸã¯ä¸€æµã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆè€…ã§ã™ã€‚ä»¥ä¸‹ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’åˆ†æã—ã€æœ€é©ãªãƒ—ãƒ¬ã‚¼ãƒ³æ§‹æˆæ¡ˆã¨ãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ã‚’JSONã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
            è¿”å´ã™ã‚‹JSONã¯ã€å¿…ãšä»¥ä¸‹ã®ã‚­ãƒ¼ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™:
            - "theme_colors": { "color1": "#HEXCODE", "color2": "#HEXCODE" } (ãƒ¬ãƒãƒ¼ãƒˆã®é›°å›²æ°—ã«åˆã†ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼2è‰²ã€‚å¿…ãš6æ¡ã®16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§æŒ‡å®šã—ã¦ãã ã•ã„)
            - "slides": array (ã‚¹ãƒ©ã‚¤ãƒ‰æ§‹æˆæ¡ˆã®é…åˆ—)

            ã‚¹ãƒ©ã‚¤ãƒ‰æ§‹æˆæ¡ˆã®å„é…åˆ—è¦ç´ ã¯ã€ä»¥ä¸‹ã®ã‚­ãƒ¼ã‚’æŒã¤JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™:
            - "title": string (ã‚¹ãƒ©ã‚¤ãƒ‰ã®ã‚¿ã‚¤ãƒˆãƒ«)
            - "layout": 'title_slide' | 'section_header' | 'content_with_visual' | 'content_only' | 'quote' (ã‚¹ãƒ©ã‚¤ãƒ‰ã®å½¹å‰²ã«å¿œã˜ãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚¿ã‚¤ãƒ—)
            - "bullets": string[] (ã‚¹ãƒ©ã‚¤ãƒ‰ã®è¦ç‚¹ã‚’ç®‡æ¡æ›¸ãã§)
            - "visual_suggestion": 'bar_chart' | 'pie_chart' | 'line_chart' | 'none' (ã‚°ãƒ©ãƒ•ã®ææ¡ˆã€ä¸è¦ãªã‚‰'none')
            - "context_for_visual": string (ã‚°ãƒ©ãƒ•ä½œæˆã«å¿…è¦ãªæ–‡è„ˆ)
            - "special_content": string (ä»»æ„ã€‚å¼•ç”¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å ´åˆã®å¼•ç”¨æ–‡ãªã©)
            
            æœ€åˆã®ã‚¹ãƒ©ã‚¤ãƒ‰ã¯å¿…ãš layout: 'title_slide' ã«ã—ã€é€”ä¸­ã«åŒºåˆ‡ã‚Šã¨ã—ã¦ layout: 'section_header' ã‚’é©åˆ‡ã«é…ç½®ã—ã¦ãã ã•ã„ã€‚
            --- ãƒ¬ãƒãƒ¼ãƒˆ ---
            ${reportContent}`;
            
            designResult = await summarizeAndAnalyzeTool.execute({ ...params, context: { text: reportContent, objective: prompt } });
            if (!designResult.success) {
                const message = `Designer AI failed: ${designResult.message}`;
                logger.error({ error: designResult.message }, message);
                return { presentationDesign: [], reportContent, fileNameBase, errorMessage: message, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
            }

            const designData = parseJsonStrings(designResult.data.summary);
            if (!designData) {
                const message = "Failed to parse presentation design JSON from AI.";
                logger.error({ aiOutput: designResult.data.summary }, message);
                return { presentationDesign: [], reportContent, fileNameBase, errorMessage: message, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
            }

            // --- Robust AI Response Parsing ---
            // The AI might return JSON in slightly different formats, so we try multiple schemas.
            const expectedObjectSchema = z.object({
                theme_colors: z.object({ color1: hexColorSchema, color2: hexColorSchema }),
                slides: z.array(slideDesignSchema),
            });
            const arrayOnlySchema = z.array(slideDesignSchema);

            // 1. Try parsing the expected object format: { theme_colors: ..., slides: [...] }
            let objectParseResult = expectedObjectSchema.safeParse(designData);
            if (objectParseResult.success) {
                const { slides, theme_colors } = objectParseResult.data;
                return { presentationDesign: slides, reportContent, fileNameBase, themeColor1: theme_colors.color1, themeColor2: theme_colors.color2 };
            }

            // 2. Try parsing a direct array of slides (if theme is missing).
            let arrayParseResult = arrayOnlySchema.safeParse(designData);
            if (arrayParseResult.success) {
                logger.warn("AI returned an array instead of an object. Using default theme colors.");
                return { presentationDesign: arrayParseResult.data, reportContent, fileNameBase, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
            }
            
            // 3. Try parsing a wrapped array, e.g., { "slides": [...] }.
            if (!Array.isArray(designData) && typeof designData === 'object' && designData !== null) {
                const keys = Object.keys(designData);
                if (keys.length === 1 && Array.isArray(designData[keys[0]])) {
                    const wrappedArray = designData[keys[0]];
                    let wrappedArrayParseResult = arrayOnlySchema.safeParse(wrappedArray);
                    if (wrappedArrayParseResult.success) {
                        logger.warn("AI returned a wrapped array. Extracting array and using default theme colors.");
                        return { presentationDesign: wrappedArrayParseResult.data, reportContent, fileNameBase, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
                    }
                }
            }

            // If all parsing attempts fail, forward an error.
            const message = `AI output did not match any expected schema. Zod error: ${objectParseResult.error.message}`;
            logger.error({ error: objectParseResult.error, aiOutput: designData }, message);
            return { presentationDesign: [], reportContent, fileNameBase, errorMessage: message, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };

        } catch (error) {
            const message = error instanceof Error ? error.message : "An unknown error occurred during presentation design.";
            logger.error({ error, aiOutput: (designResult && designResult.success) ? designResult.data.summary : 'AI output not available.' }, message);
            return { presentationDesign: [], reportContent, fileNameBase, errorMessage: message, themeColor1: '#F1F1F1', themeColor2: '#CCCCCC' };
        }
    },
}))
.then(createStep({
    /**
     * @step generate-title-image
     * Generates a background image for the title slide based on its title.
     * This step is optional; if it fails, the workflow continues without a title image.
     */
    id: 'generate-title-image',
    inputSchema: z.object({
        presentationDesign: z.array(slideDesignSchema),
        reportContent: z.string(),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        errorMessage: z.string().optional(),
    }),
    outputSchema: z.object({
        presentationDesign: z.array(slideDesignSchema),
        reportContent: z.string(),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    execute: async (params) => {
        const { presentationDesign, reportContent, fileNameBase, errorMessage, themeColor1, themeColor2 } = params.inputData;
        if (errorMessage || presentationDesign.length === 0) {
            return { ...params.inputData, titleSlideImagePath: undefined };
        }
        
        const titleSlide = presentationDesign[0];
        // We only generate an image for the title slide.
        if (titleSlide.layout !== 'title_slide') {
            return { ...params.inputData, titleSlideImagePath: undefined };
        }

        logger.info("ğŸ¨ [Image Generator] Generating background image for the title slide...");

        try {
            // Step 1: Use an AI to distill the title into visual keywords.
            // This prevents the image generator from trying to render the literal title text.
            const keywordExtractionPrompt = `From the following presentation title, extract 5-7 core visual keywords suitable for generating an abstract background image. The keywords should focus on concepts, themes, and colors. Do not include the original title text. Output only a comma-separated list. Title: "${titleSlide.title}"`;

            const keywordResult = await summarizeAndAnalyzeTool.execute({
                ...params,
                context: {
                    text: titleSlide.title,
                    objective: keywordExtractionPrompt,
                }
            });

            if (!keywordResult.success) {
                logger.warn("Failed to extract keywords for title image. Skipping image generation.");
                return { ...params.inputData, titleSlideImagePath: undefined };
            }

            const keywords = keywordResult.data.summary.trim();
            logger.info({ keywords }, "Extracted keywords for title image.");

            // Step 2: Generate an image using only the distilled keywords.
            const prompt = `An abstract, professional background image representing the following themes: ${keywords}. High resolution, clean, and visually appealing.`;
            const negativePrompt = 'text, words, letters, numbers, writing, typography, signatures, logos, people, faces';

            const { generateImage } = await import('../../tools/xibo-agent/generateImage/imageGeneration');
            const imageResult = await generateImage.execute({
                ...params,
                context: {
                    prompt,
                    aspectRatio: '16:9',
                    negativePrompt,
                },
            });

            if (imageResult.success && imageResult.data?.imagePath) {
                const fullImagePath = imageResult.data.imagePath;
                return { ...params.inputData, titleSlideImagePath: fullImagePath };
            } else {
                logger.warn("Failed to generate title slide image.", { error: imageResult.message });
                return { ...params.inputData, titleSlideImagePath: undefined };
            }
        } catch (error) {
            const message = error instanceof Error ? error.message : "An unknown error occurred during title image generation.";
            logger.error({ error }, message);
            // Don't propagate this as a workflow-stopping error. Just proceed without the image.
            return { ...params.inputData, titleSlideImagePath: undefined };
        }
    },
}))
.then(createStep({
    /**
     * @step generate-content
     * Enriches the presentation design with actual content. For each slide, it:
     * 1. Generates a speech script using an AI.
     * 2. If a visual is suggested, uses an AI to extract or create data for a chart.
     * These operations are run in parallel for efficiency.
     */
    id: 'generate-content',
    inputSchema: z.object({
        presentationDesign: z.array(slideDesignSchema),
        reportContent: z.string(),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    outputSchema: z.object({
        enrichedSlides: z.array(z.object({
            design: slideDesignSchema,
            chartData: chartDataSchema.nullable(),
            speech: z.string(),
        })),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    execute: async (params) => {
        const { presentationDesign, reportContent, fileNameBase, errorMessage, themeColor1, themeColor2, titleSlideImagePath } = params.inputData;
        if (errorMessage) {
            return { enrichedSlides: [], fileNameBase, errorMessage, themeColor1, themeColor2, titleSlideImagePath };
        }

        logger.info("âœï¸ [Analyst & Speechwriter AIs] Generating chart data and speech scripts...");
        const contentGenerationPromises = presentationDesign.map(async (design) => {
            // Concurrently generate speech and chart data for the current slide.
            const speechPromise = summarizeAndAnalyzeTool.execute({ ...params, context: {
                text: `- ã‚¿ã‚¤ãƒˆãƒ«: ${design.title}\n- è¦ç‚¹: ${design.bullets.join(', ')}`,
                objective: `ã‚ãªãŸã¯ã“ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã®ãƒ—ãƒ¬ã‚¼ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚ä¸Šè¨˜ã®ã‚¿ã‚¤ãƒˆãƒ«ã¨è¦ç‚¹ã«åŸºã¥ãã€ç´„150å­—ç¨‹åº¦ã®è‡ªç„¶ã§èãã‚„ã™ã„ã‚¹ãƒ”ãƒ¼ãƒåŸç¨¿ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚`,
            }});

            let chartDataPromise: Promise<ChartData | null> = Promise.resolve(null);
            if (design.visual_suggestion !== 'none') {
                // This async block is wrapped in a promise for parallel execution.
                chartDataPromise = (async () => {
                    const analystPrompt = `ã‚ãªãŸã¯å„ªç§€ãªãƒ‡ãƒ¼ã‚¿ã‚¢ãƒŠãƒªã‚¹ãƒˆã§ã™ã€‚ä»¥ä¸‹ã®ãƒ¬ãƒãƒ¼ãƒˆæœ¬æ–‡ã¨ã‚¹ãƒ©ã‚¤ãƒ‰ã®æ–‡è„ˆæƒ…å ±ã‚’æ³¨æ„æ·±ãåˆ†æã—ã€ã€Œ${design.context_for_visual}ã€ã¨ã„ã†ãƒ†ãƒ¼ãƒã«æœ€ã‚‚é–¢é€£æ€§ã®é«˜ã„ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚
ãã®ãƒ‡ãƒ¼ã‚¿ã‚’åŸºã«ã€${design.visual_suggestion.replace('_', ' ')}ã‚’æç”»ã™ã‚‹ãŸã‚ã®JSONãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

**JSONå‡ºåŠ›ã®å³æ ¼ãªãƒ«ãƒ¼ãƒ«:**
- å½¢å¼: \`{ "chart_type": "${design.visual_suggestion.replace('_chart', '')}", "title": "ã‚°ãƒ©ãƒ•ã®ã‚¿ã‚¤ãƒˆãƒ«", "labels": ["é …ç›®1", "é …ç›®2", ...], "data": [æ•°å€¤1, æ•°å€¤2, ...] }\`
- \`labels\`ã¨\`data\`ã®é…åˆ—ã®è¦ç´ æ•°ã¯å¿…ãšä¸€è‡´ã•ã›ã¦ãã ã•ã„ã€‚
- æ•°å€¤ã¯å¿…ãš\`number\`å‹ã«ã—ã¦ãã ã•ã„ã€‚æ–‡å­—åˆ—ã®æ•°å€¤ã¯è¨±å¯ã•ã‚Œã¾ã›ã‚“ã€‚

**ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã®ãƒ’ãƒ³ãƒˆ:**
- ãƒ¬ãƒãƒ¼ãƒˆå†…ã®å…·ä½“çš„ãªæ•°å€¤ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã€æ—¥ä»˜ã€æœŸé–“ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚
- ã‚‚ã—ç›´æ¥çš„ãªæ•°å€¤ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã§ã‚‚ã€ãƒ¬ãƒãƒ¼ãƒˆã®ä¸»å¼µã‚’è£œå¼·ã™ã‚‹è±¡å¾´çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ã€Œæˆé•·ã€ã‚’ç¤ºã™æ–‡è„ˆã§ã‚ã‚Œã°ã€å³è‚©ä¸ŠãŒã‚Šã®å‚¾å‘ã‚’æŒã¤æ¶ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚
- ã©ã†ã—ã¦ã‚‚é©åˆ‡ãªãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã§ããªã„å ´åˆã¯ã€\`null\`ã‚’è¿”ã™ã®ã§ã¯ãªãã€\`{ "chart_type": "error", "title": "ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆä¸å¯", "labels": ["ç†ç”±"], "data": [0] }\` ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã‚’ç¤ºã™JSONã‚’è¿”ã—ã¦ãã ã•ã„ã€‚

**ãƒ¬ãƒãƒ¼ãƒˆæœ¬æ–‡:**
---
${reportContent}
---
`;
                    const analystResult = await summarizeAndAnalyzeTool.execute({ ...params, context: { text: reportContent, objective: analystPrompt }});
                    if (!analystResult.success) return null;
                    const parsed = parseJsonStrings(analystResult.data.summary);
                    if (parsed && parsed.chart_type === 'error') return null; // Handle explicit error from AI
                    try {
                        // Attempt to parse the AI's JSON output against the schema.
                        return parsed ? chartDataSchema.parse(parsed) : null;
                    } catch { return null; }
                })();
            }

            const [speechResult, chartData] = await Promise.all([speechPromise, chartDataPromise]);
 
            let speech = "ï¼ˆåŸç¨¿ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸï¼‰";
            if (speechResult.success) {
                const rawSpeech = speechResult.data.summary;
                // The AI sometimes includes preamble. We split by '---' and take the last part.
                const parts = rawSpeech.split('---');
                
                let baseSpeech;
                if (parts.length > 1) {
                    baseSpeech = (parts.pop() || '').trim();
                } else {
                    baseSpeech = rawSpeech.trim();
                }

                // Add newlines after periods for better readability in the notes section.
                speech = baseSpeech.replace(/([ã€‚\.])/g, '$1\n');
            }

             return {
                 design,
                 chartData,
                speech,
             };
         });

        const enrichedSlides = await Promise.all(contentGenerationPromises);
        return { enrichedSlides, fileNameBase, themeColor1, themeColor2, titleSlideImagePath };
    },
}))
.then(createStep({
    /**
     * @step generate-visuals
     * Creates PNG images for any charts defined in the previous step.
     * It also includes fallback logic: if a slide is supposed to have a visual but
     * chart generation fails, it changes the slide's layout to 'content_only'
     * to avoid an empty space in the presentation.
     */
    id: 'generate-visuals',
    inputSchema: z.object({
        enrichedSlides: z.array(z.object({
            design: slideDesignSchema,
            chartData: chartDataSchema.nullable(),
            speech: z.string(),
        })),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    outputSchema: z.object({
        finalSlides: z.array(z.object({
            title: z.string(),
            bullets: z.array(z.string()),
            imagePath: z.string().optional(),
            notes: z.string(),
            layout: z.enum(['title_slide', 'section_header', 'content_with_visual', 'content_only', 'quote']),
            special_content: z.string().optional(),
        })),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    execute: async (params) => {
        const { enrichedSlides, fileNameBase, errorMessage, themeColor1, themeColor2, titleSlideImagePath } = params.inputData;
        if (errorMessage) {
            return { finalSlides: [], fileNameBase, errorMessage, themeColor1, themeColor2, titleSlideImagePath };
        }

        logger.info("ğŸ–¼ï¸ [Chart Generator] Creating chart images...");
        const finalSlidesPromises = enrichedSlides.map(async (slide, index) => {
            let imagePath: string | undefined = undefined;
            // Attempt to generate a chart if data is present
            if (slide.chartData) {
                const { chart_type, ...restOfChartData } = slide.chartData;
                const chartResult = await generateChartTool.execute({ ...params, context: { ...restOfChartData, chartType: chart_type, fileName: `chart_${fileNameBase}_${index}` }});
                if (chartResult.success) {
                    imagePath = chartResult.data.imagePath;
                } else {
                    logger.warn({ slideTitle: slide.design.title }, "Chart generation failed, proceeding without an image.");
                }
            }

            // Fallback logic: If layout requires a visual but we don't have one, change layout.
            let finalLayout = slide.design.layout;
            if (finalLayout === 'content_with_visual' && !imagePath) {
                logger.info({ slideTitle: slide.design.title }, "Visual not available for 'content_with_visual' layout. Switching to 'content_only'.");
                finalLayout = 'content_only';
            }

            return {
                title: slide.design.title,
                bullets: slide.design.bullets,
                imagePath: imagePath,
                notes: slide.speech,
                layout: finalLayout,
                special_content: slide.design.special_content,
            };
        });

        const finalSlides = await Promise.all(finalSlidesPromises);
        return { finalSlides, fileNameBase, themeColor1, themeColor2, titleSlideImagePath };
    },
}))
.then(createStep({
    /**
     * @step assemble-outputs
     * Takes all the generated components (slide designs, text, image paths)
     * and uses the `createPowerpointTool` to assemble the final .pptx file.
     */
    id: 'assemble-outputs',
    inputSchema: z.object({
        finalSlides: z.array(z.object({
            title: z.string(),
            bullets: z.array(z.string()),
            imagePath: z.string().optional(),
            notes: z.string(),
            layout: z.enum(['title_slide', 'section_header', 'content_with_visual', 'content_only', 'quote']),
            special_content: z.string().optional(),
        })),
        fileNameBase: z.string(),
        themeColor1: z.string(),
        themeColor2: z.string(),
        titleSlideImagePath: z.string().optional(),
        errorMessage: z.string().optional(),
    }),
    outputSchema: finalOutputSchema,
    execute: async (params) => {
        const { finalSlides, fileNameBase, errorMessage, themeColor1, themeColor2, titleSlideImagePath } = params.inputData;
        if (errorMessage) {
            return { success: false, message: errorMessage } as const;
        }

        logger.info("ğŸ“¦ [Assembler] Creating final PowerPoint file with notes...");
        const pptResult = await createPowerpointTool.execute({ ...params, context: { 
            fileName: fileNameBase,
            slides: finalSlides,
            themeColor1,
            themeColor2,
            titleSlideImagePath,
        }});

        if (!pptResult.success) {
            return { success: false, message: `Failed to assemble final PowerPoint file: ${pptResult.message}` } as const;
        }

        return {
            success: true,
            data: {
                powerpointPath: pptResult.data.filePath,
            },
        } as const;
    },
}))
.commit();